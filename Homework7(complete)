#include <stdio.h>
#include <stdlib.h>
#define MAX_SIZE 200

int count = 0;

//노드 구조체
typedef struct Node {
	int data;
	struct Node* left, * right;
}Node;

//힙 구조체
typedef struct {
	Node* heap[MAX_SIZE];
	int heap_size;
	int front;
	int rear;
}HeapType;


//큐 구조체
typedef struct Queue
{
	int capacity;
	int front;
	int rear;

	Node* Nodes;  //큐 요소에 배열에 대한 포인터 
}Queue;

//큐 생성
void CreateQueue(Queue** _Queue, int capacity)
{
	(*_Queue) = (Queue*)malloc(sizeof(Queue));
	(*_Queue)->capacity = capacity;
	(*_Queue)->front = 0;
	(*_Queue)->rear = 0;
}

//큐 노드 삽입
void Enqueue(Queue* _Queue, int data)
{
	int position = 0;

	if (_Queue->rear == _Queue->capacity)
	{
		position = _Queue->rear;
		_Queue->rear = 0;
	}
	else
		position = _Queue->rear++;

	_Queue->Nodes[position].data = data;
}


//큐 노드 제거 
Node* Dequeue(Queue* _Queue)
{
	int position = _Queue->front;

	//전단이 배열 끝에 도달
	if (_Queue->front == _Queue->capacity)
		_Queue->front = 0;
	else
		_Queue->front++;

	return _Queue->Nodes[position].data;
}

//큐 공백 확인
int Q_isEmpty(Queue* _Queue)
{
	return(_Queue->front == _Queue->rear);
}



//힙 생성
HeapType* create()
{
	return (HeapType*)malloc(sizeof(HeapType));

}

//힙 초기화 
void init(HeapType* h)
{
	h->heap_size = 0;
}


//힙 삽입
void insert_Heap(HeapType* h, int item)
{
	//큐 선언
	Queue* _Queue;

	int i;
	h->heap_size = h->heap_size + 1;
	i = h->heap_size;
	
	//트리를 거슬러 올라가면서 부모 노드와 비교하는 과정
	while ((i != 1) && (item > h->heap[i / 2]))
	{
		count++;
		//i번째 노드와 부모 노드 교환
		h->heap[i] = h->heap[i / 2];
		//한 레벨 위로 올라감
		i /= 2;
	}
	h->heap[i] = item; //새로운 노드를 삽입
	Enqueue(_Queue, item); //큐에 새로운 노드 삽입
}

//힙 삭제
int delete_Heap(HeapType* h)
{
	//큐 선언
	Queue* _Queue;

	int parent, child;
	int item, temp;

	//루트 노드 값을 반환하기 위해 item에 할당
	item = h->heap[1];
	//마지막 노드를 temp에 할당
	temp = h->heap[(h->heap_size)--];
	parent = 1;
	child = 2;

	while (child <= h->heap_size)
	{
		count++;
		//현재 노드의 자식 노드 중 더 큰 자식 노드를 찾음
		if ((child <= h->heap_size) && (h->heap[child]) < h->heap[child + 1])
			child++;
		//더 큰 자식의 노드보다 마지막 노드가 크면, while문 중지
		if (temp >= h->heap_size) break;

		//더 큰 자식 노드보다 마지막 노드가 작으면, 부모노드와 더 큰 자식 노드를 교환
		h->heap[parent] = h->heap[child];
		parent = child;
		child = child * 2;
				
	}
	//마지막 노드를 재구성한 위치에 삽입
	h->heap[parent] = temp;
	Dequeue(_Queue); //큐에서 최상단 노드 제거  
	return item;

}

//레벨 순회 
void level_order(Node* _node)
{
	Queue* _Queue;
	CreateQueue(_Queue, MAX_SIZE);
	if (_node == NULL) return;
	Enqueue(&_Queue, _node);
	while (!Q_isEmpty(&_Queue))
	{
		
		_node = Dequeue(&_Queue);
		printf("%d", _node->data);
		if (_node->left) Enqueue(&_Queue, _node->left);
		if (_node->right) Enqueue(&_Queue, _node->right);
	}
}



int main()
{
	printf("-----------------\n");
	printf("1: 노드 추가\n");
	printf("2: 노드 삭제\n");
	printf("3: 레벨별 출력\n");
	printf("4:종료\n");
	printf("-----------------\n");

	int menu;
	int data;
	HeapType* _heap = create();
	init(_heap);

	Node* _node;
	

	do {
		printf("메뉴 입력:");
		scanf_s("%d", &menu);

		switch (menu)
		{
		case 1:
			printf("추가할 값 입력:");
			scanf_s("%d", &data);
			insert_Heap(_heap, data);
			level_order(_node);
			break;

		case 2:
			delete_Heap(_heap);
			break;

		case 3:
			printf("레벨별 출력:");
			break;

		case 4:
			printf("종료합니다.");
			break;

		default:
			printf("메뉴를 다시 선택하세요.\n");
			return 0;
		}
	} while (menu != 4);

	return 0;
}
